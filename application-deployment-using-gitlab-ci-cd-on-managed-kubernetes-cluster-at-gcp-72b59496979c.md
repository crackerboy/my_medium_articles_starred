Unknown markup type 10 { type: [33m10[39m, start: [33m7[39m, end: [33m25[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m7[39m, end: [33m26[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m7[39m, end: [33m21[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m149[39m, end: [33m163[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m114[39m, end: [33m138[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m131[39m, end: [33m153[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m7[39m, end: [33m26[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m131[39m, end: [33m149[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m174[39m, end: [33m194[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m106[39m, end: [33m111[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m7[39m, end: [33m27[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m61[39m, end: [33m81[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m86[39m, end: [33m105[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m45[39m, end: [33m75[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m204[39m, end: [33m232[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m308[39m, end: [33m321[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m326[39m, end: [33m330[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m27[39m, end: [33m71[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m76[39m, end: [33m119[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m252[39m, end: [33m271[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m56[39m, end: [33m75[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m7[39m, end: [33m22[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m58[39m, end: [33m72[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m137[39m, end: [33m165[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m75[39m, end: [33m88[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m60[39m, end: [33m72[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m106[39m, end: [33m120[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m167[39m, end: [33m181[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m255[39m, end: [33m273[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m360[39m, end: [33m369[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m378[39m, end: [33m385[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m9[39m, end: [33m27[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m60[39m, end: [33m80[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m116[39m, end: [33m129[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m229[39m, end: [33m247[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m51[39m, end: [33m65[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m102[39m, end: [33m120[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m8[39m, end: [33m15[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m85[39m, end: [33m104[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m140[39m, end: [33m173[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m255[39m, end: [33m259[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m264[39m, end: [33m270[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m282[39m, end: [33m293[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m364[39m, end: [33m383[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m519[39m, end: [33m522[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m530[39m, end: [33m541[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m613[39m, end: [33m620[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m56[39m, end: [33m71[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m140[39m, end: [33m159[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m218[39m, end: [33m231[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m293[39m, end: [33m313[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m63[39m, end: [33m77[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m117[39m, end: [33m121[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m68[39m, end: [33m79[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m46[39m, end: [33m61[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m46[39m, end: [33m50[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m98[39m, end: [33m109[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m52[39m, end: [33m70[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m21[39m, end: [33m32[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m48[39m, end: [33m69[39m }

# Application Deployment using Gitlab CI/CD on Managed Kubernetes Cluster at GCP

Step by Step guide to deploy a mono-repo of microservices on GCP using Gitlab CI/CD Pipelines.

![](https://cdn-images-1.medium.com/max/2000/1*dbK6DLeZiJAzj_87-z0fPA.png)

In continuation of my [previous article](https://medium.com/@arslan_53972/microservices-based-application-deployment-using-gitlab-ci-cd-on-docker-swarm-at-digital-ocean-586eefb07294) where I’ve deployed the same mono-repo of microservices application on Docker Swarm instead of Kubernetes, we will repeat most of the steps and I will try to be brief about all the steps except the deployment configuration. So it is highly recommended that you read [this article](https://medium.com/@arslan_53972/microservices-based-application-deployment-using-gitlab-ci-cd-on-docker-swarm-at-digital-ocean-586eefb07294) first.

## Pre-requisites

You need to have billing enabled account on GCP (Google Cloud Platform) for creating and running a Kubernetes cluster.
> [The complete code of this article resides here…](https://gitlab.com/docker-microservice/ci-cd-example-voting-app-k8s)

## **Agenda**

In this article, we will clone the Docker’s official sample [voting app microservices example](https://github.com/dockersamples/example-voting-app.git) into a Gitlab repository and implement CI/CD on a Kubernetes Cluster. I have broken it down into the following key steps:

1. Create a Repository in a Repository Group at Gitlab

1. Create a K8s Cluster on GCP using Gitlab Integration

1. Install Helm, Gitlab Runner, Cert-Manager and Ingress on K8s Cluster

1. Change docker-compose.ymlto add image names

1. Change kube-deployment.ymlto contain Gitlab Environment Variables

1. Create .gitlab-ci.ymlfor the project.

## Create Repository

Create the repository in your Gitlab account for [voting app microservices example](https://github.com/dockersamples/example-voting-app.git) using the CI/CD for External Repo option tab. Details on how to create it can be found [here.](https://medium.com/@arslan_53972/microservices-based-application-deployment-using-gitlab-ci-cd-on-docker-swarm-at-digital-ocean-586eefb07294)

## Create Kubernetes Cluster on GCP

Gitlab provides the simplest way to create K8s cluster on GCP by using OAuth to log in to your Google Cloud Platform account and then by providing a simple form to select your project and other configurations for the required cluster. Do go through the [**Before you begin instructions](https://docs.gitlab.com/ee/user/project/clusters/add_remove_clusters.html#before-you-begin)** for GCP integration with Gitlab.

Simply open your Gitlab Project -> Operations -> Kubernetes -> Add Kubernetes Cluster and then select Google GKE. It will request you to login using your Google Account for GCP. Once done you will be required to fill the following:

![Logged In using Google OAuth](https://cdn-images-1.medium.com/max/6720/1*avyH3eUYZ0bk4tCH4G45OQ.png)*Logged In using Google OAuth*

![Fill the Required Cluster Configuration](https://cdn-images-1.medium.com/max/6720/1*gqjFskI5mhiU0ieQS8XTIw.png)*Fill the Required Cluster Configuration*

I have used **e2-small** as we are going to deploy a very basic application, however, you can choose a better machine size based on your application requirements. I have already created a Project in GCP with **billing**, **GKE** and other required APIs enabled. If you don't have one then click the Google Cloud Platform link below the **GCP Project** field and create one. Do not check the **Enable Cloud Run for Anthos** for now, as I will create another post for Cloud Runs where we will use the power of Anthos to deploy Application on Hybrid Cloud.

Now since your K8s Cluster is ready and integrated with Gitlab, so let's start with configuring it.

## Install Helm, Gitlab Runner, Cert-Manager and Ingress on K8s Cluster

We need Helm Tiler to install other applications on our Clusters, so start off with the Installation of Helm. Once done then we would need a Gitlab Runner to run our CI/CD pipelines, we can utilize a separate Gitlab Runner but running it inside K8s cluster will allow us to run concurrent jobs as the runner will autoscale to full fill the requirements. Next, we need Cert-Manager; it is a native [Kubernetes](https://kubernetes.io/) certificate management controller. It can help with issuing certificates from a variety of sources, such as [Let’s Encrypt](https://letsencrypt.org/), [HashiCorp Vault](https://www.vaultproject.io/), [Venafi](https://www.venafi.com/), a simple signing key pair, or self-signed. It will ensure certificates are valid and up to date, and attempt to renew certificates at a configured time before expiry. At last, we would need an Ingress Controller to route outside traffic to the inside of our cluster.

![Installed Applications on K8s Cluster](https://cdn-images-1.medium.com/max/6720/1*ZYqRVkzXBlVbrhRSM_toCw.png)*Installed Applications on K8s Cluster*

Once the ingress is installed you will get the Ingress Endpoint IP address to copy it and use it to make the Base Domain for your cluster as follows 1.2.3.4.nip.io and then press Save Changes. If you have a base domain with wildcard DNS configured then please use it instead.
> Entering a Base Domain with wildcard DNS support is very important for the CICD to work properly. As the value of KUBE_INGRESS_BASE_DOMAIN will be null if not saved here.

![Assign Ingress Endpoint as Base Domain using nip.io service](https://cdn-images-1.medium.com/max/6720/1*7VyVTcgdN_ZsrQQcB0XtlA.png)*Assign Ingress Endpoint as Base Domain using nip.io service*
> Note: Once you are done installing the Gitlab Runner on kubernetes cluster, then goto your Project Settings -> CI/CD -> Runner and Disable Shared Runners for this project.

## Change docker-compose.yml to add image names

Since its a mono-repo which means all microservices are part of a single repository, so to build docker images we will make use of docker-compose.yml. We will issue a single docker-compose build command and it will start building images for all microservices. However since we are going to store our Docker images on Gitlab provided Docker Registry so let's change the image field of vote, result and worker microservice in the following format:

    image: __CI_REGISTRY_IMAGE__/vote:latest
> [Here is the full code of docker-compose.yml.](https://gitlab.com/docker-microservice/ci-cd-example-voting-app-k8s/-/blob/0b94482c6dd60e529ceed07c39ca73f7d7fc2d5b/docker-compose.yml)

This way we are declaring a variable __CI_REGISTRY_IMAGE__ which we will replace while building it in our build CI/CD stage.

## Change kube-deployment.yml to contain Gitlab Environment Variables

Similar to the above step we need to make some variables for kube-deployment.yml too. kube-deployment.yml contains all the manifests for creating and scaling our microservices. Each microservice is pulled following important fields:

**Labels
**Labels help us to group resources e.g app: redis-__CI_PROJECT_NAME__ will help us address a particular Redis deployment even if we have multiple Redis deployments for different projects, similarly ref:__CI_ENVIRONMENT_SLUG__ will help us identify the deployments of different environments for example review-master and live for the production environment.

**Annotations
**We will create app.gitlab.com/app: __CI_PROJECT_PATH_SLUG__ and app.gitlab.com/env: __CI_ENVIRONMENT_SLUG__ annotations for all of the pod templates under deployments to help Gitlab identify the deployments and show the rollout progress in environments tab like below:

![Live environment rollout status](https://cdn-images-1.medium.com/max/6720/1*SYWxcQ20QMTX2INgtftZIA.png)*Live environment rollout status*

**Image
**We need to keep the image field completely dynamic i.e in our current scenario we need to build different images for each build, we want to tag images with the appropriate version number or even branch names. We don't want to manually change the kube-deployment.yml every time we push a branch or a tag. So we will make reconfigure the image field as follows:

    containers:
    - name: result
      **image: __CI_REGISTRY_IMAGE__/result:__VERSION__**
      ports:
      - containerPort: 80
        name: result
> [Here is the full code of kube-deployment.yml.](https://gitlab.com/docker-microservice/ci-cd-example-voting-app-k8s/-/blob/master/kube-deployment.yml)

**Ingress Resource
**The ingress resource is missing in the kube-deployment.yml provided by Docker Sample. So let's create it as follows:

    ---
    # Ingress Resource

    apiVersion: networking.k8s.io/v1beta1
    kind: Ingress
    metadata:
      name: app-ingress
      annotations:
        kubernetes.io/tls-acme: "true"
        kubernetes.io/ingress.class: "nginx"
      labels:
        app: ingress-__CI_PROJECT_NAME__
        ref: __CI_ENVIRONMENT_SLUG__

    spec:
      tls:
      - hosts:
        - __CI_ENVIRONMENT_SLUG__.result.104.154.109.250.nip.io
        - __CI_ENVIRONMENT_SLUG__.104.154.109.250.nip.io
        # the secret used here is an unsigned wildcard cert for demo      purposes
        # use your own or comment this out
        secretName: tls-some-wildcard-demo
      rules:
      - host: __CI_ENVIRONMENT_SLUG__.result.104.154.109.250.nip.io
        http:
         paths:
         - path: /
           backend:
             serviceName: result
             servicePort: 5001
      - host: __CI_ENVIRONMENT_SLUG__.104.154.109.250.nip.io
        http:
         paths:
         - path: /
           backend:
             serviceName: vote
             servicePort: 5000

    ---
> [Here is the full code of kube-deployment.yml.](https://gitlab.com/docker-microservice/ci-cd-example-voting-app-k8s/-/blob/master/kube-deployment.yml)

An Ingress Resource is just another Kubernetes resources with **apiVersion**, **kind**, **metadata**, and **spec**. However, in the **spec** section, we have to specify if the ingress has tls certificates available in its tls section. This is where the **Cert-Manager** will take the provided secretName and create Certificate authorities and keys automatically and generate tls certificates using Lets Encrypt service. Next comes the routing rules, this is where we need to specify hosts for each of our front-end microservice. In our case both Vote and Result Microservices are front-end microservices, so we will provide Environment Slug (review / live) as part of our DNS Domain name. If it is unclear, then please note that we will investigate environments more deeply when we will deploy our application.

## Create .gitlab-ci.yml for the project

Now since we have set up everything, let’s start with our .gitlab-ci.yml , we will start with stages, this time we will create 4 stages as follows:

    stages:
    - build
    - review
    - test
    - deploy

**Build
**In this stage, we will build all the microservices images. We will tag them and push them to Docker Registry.

**Review
**For every commit other than tags, we will create a review/staging environment and deploy it in a staging environment. For example review.result.1.2.3.4.nip.io

**Test
**Before deploying to production, we need to run all our integration tests here.

**Deploy
**In this stage, we will deploy our application in a production environment.

## **Deep Dive in .gitlab-ci.yml CI/CD Jobs**

I have created a few bash helper script functions and declared them in the before_script section of the whole pipeline. Which means they will be available in all jobs before running the script section.

In our CI/CD Pipeline the first Job will be the build stage, let's look into its code:

    k8s-build-production:

      variables:
        DOCKER_HOST: tcp://localhost:2375

      stage: build

      script:
        - registry_login
        - install_compose
        - sed_files compose
        - docker-compose build --pull --compress --force-rm
        - push_registry

      only:
        - master
> [Here is the full code of .gitlab-yml](https://gitlab.com/docker-microservice/ci-cd-example-voting-app-k8s/-/blob/0b94482c6dd60e529ceed07c39ca73f7d7fc2d5b/.gitlab-ci.yml)

In the script section, we first log into our registry using docker login , then we make sure that we have docker-compose available. Once we are all set with login and docker-compose installation then we need to substitute the environment variables in our docker-compose.yml with Gitlab predefined environment variables for which I have created a helper method sed_files we pass compose as a string variable to this function. This method makes use of Linux SED utility to substitute the variables (you may also use [envsubst](https://github.com/a8m/envsubst)).

Once our docker-compose.yml file is updated, we can run the docker-compose build command to prepare all the images. push_registry the function simply pushes the built images to our Container Registry with appropriate tags.

Now the build starts consecutively when we make a change in the master branch, however, if we want to bump a new version tag we need to make sure that all docker images are also bumped with the same tags. That is why I created a k8s-tag-production job.

    k8s-tag-production:

      variables:
        DOCKER_HOST: tcp://localhost:2375

      stage: build

      only:
        - tags

      script:
        - registry_login
        - install_compose
        - sed_files compose
        - docker-compose pull
        - push_registry

Now this build runs only when a new version is pushed using:

    $ git tag v1.1.0 -m 'Version 1.1.0'
    $ git push origin v1.1.0

It will also log in to Container Registry, install docker-compose and change environment variables in docker-compose.yml using SED. It will then pull all the latest pushed images and push them back while using the new version tags.

The next in line is the Review deploy stage, in this stage, we will deploy a staging environment of our app. Let us view the code:

    deploy_review:

      image:
        name: lachlanevenson/k8s-kubectl:latest
        entrypoint: ["/bin/sh", "-c"]

      stage: review

      only:
        - branches

      except:
        - tags

      environment:
        name: review/$CI_BUILD_REF_NAME
        url: [https://$CI_ENVIRONMENT_SLUG.104.154.109.250.nip.io](https://$CI_ENVIRONMENT_SLUG.104.154.109.250.nip.io)
        on_stop: stop_review

      script:
        - kubectl version
        - sed_files deployment
        - kubectl apply -f kube-deployment.yml
> [Here is the full code of .gitlab-yml](https://gitlab.com/docker-microservice/ci-cd-example-voting-app-k8s/-/blob/0b94482c6dd60e529ceed07c39ca73f7d7fc2d5b/.gitlab-ci.yml)

We need kubectlcli in this stage to deploy our microservices using the manifest file kube-deployment.yml , for this reason, we will use the lachlanevenson/k8s-kubectl:latest image. This stage will only run on branches and not on tags, that is why we used only and except fields. Theenvironment field is the most important for a review stage, as it will create the CI_ENVIRONMENT_SLUG environment variables during the execution of the jobs and utilizing that variable we will configure our ingress resource. The default url of the environment will be routed to our Votes microservices using Ingress resources. The on_stop variable takes in the name of the job we want to execute when we press the stop button from the Gitlab Environment Details page.

Initially, we begin the script execution by listing the kubectl version . We use the SED again to substitute the environment variables from kube-deployment.yml . Once completed, we simply apply the manifest file using kubectl apply command. This will create all the resources mentioned in the kube-deployment.yml.

Skipping the details of stop_review job, as it simply uses the kubectl delete command to delete all the resources of the review environment.

Let's get into the deploy_live job, this will deploy production built using the following manifest:

    deploy_live:

      image:
        name: lachlanevenson/k8s-kubectl:latest
        entrypoint: ["/bin/sh", "-c"]

      stage: deploy

      environment:
        name: live
        url: https://$CI_ENVIRONMENT_SLUG.104.154.109.250.nip.io

      only:
        - tags

      when: manual

      script:
        - kubectl version
        - sed_files deployment
        - kubectl apply -f kube-deployment.yml
> [Here is the full code of .gitlab-yml](https://gitlab.com/docker-microservice/ci-cd-example-voting-app-k8s/-/blob/0b94482c6dd60e529ceed07c39ca73f7d7fc2d5b/.gitlab-ci.yml)

The only difference between this and the review stage is that it runs only for the tags with the environment name as live

## **Demo**

First of all clone the repository [here](https://gitlab.com/docker-microservice/ci-cd-example-voting-app-k8s), add a Kubernetes cluster to it and then to test the CI/CD in action, commit a small change, the review pipeline should start building.

    $ git add .
    $ git commit -a -m 'Deploying CI/CD Pipelines for the first time'
    $ git push origin master

It will start your first pipeline, you may see it in the CI/CD tab as follows:

![Running CICD Build after commit](https://cdn-images-1.medium.com/max/6720/1*CKeVxS08h43IcHh5kfgryw.png)*Running CICD Build after commit*

Just cross-check if everything went well in the pipeline and that a stop_review job is also created with a manual trigger.

![Review Pipeline Deployed Properly](https://cdn-images-1.medium.com/max/6720/1*NnZ5TU4R88R1KUipdLQw2Q.png)*Review Pipeline Deployed Properly*

Now we open the environments page and check the rollout status. Go to Operations -> Environments

![Review environment rollout status OK](https://cdn-images-1.medium.com/max/6720/1*9hUeiZzjakS_W648BWavzg.png)*Review environment rollout status OK*

To open the application in the browser, click View Deployment .

![View Deployment](https://cdn-images-1.medium.com/max/6720/1*pzYHpII0QbPoqSFCZRksxw.png)*View Deployment*

Hooray!!!

![Apps in Action](https://cdn-images-1.medium.com/max/3360/1*HgfnH-XdP_JvJyA82hxH5w.gif)*Apps in Action*

Now, this is our review App, let’s stop the review environment and deploy the live (production) app.

To stop the review environment, just click theStop button on the previous screen, it will run the stop_review job in our pipeline. The job is configured to delete all Kubernetes resources.

![Review Environment Deleted.](https://cdn-images-1.medium.com/max/6720/1*VFGIvmF97X0af-m86WNplA.png)*Review Environment Deleted.*

To deploy live, just tag the commit with a version and push tag:

    $ git tag v1.3.0 'Bumped Version 3'
    $ git push origin v1.3.0

It will create a new pipeline and start running the k8s-tag-production job.

![Live environment Pipeline running](https://cdn-images-1.medium.com/max/6720/1*W3cimgUiDTGFzsnr0bbbAA.png)*Live environment Pipeline running*

When done, click the deploy_live job and trigger the deployment manually.

![Deploy Live Manually](https://cdn-images-1.medium.com/max/6720/1*pi4KyaVxTYbFt8lf4KfmIg.png)*Deploy Live Manually*

![Live environment deployed](https://cdn-images-1.medium.com/max/6720/1*Rvkp2iPOGSJPfQOBSyV9sg.png)*Live environment deployed*

Now let’s check the rollout status in the environments once again

![100% Rollout](https://cdn-images-1.medium.com/max/6720/1*m6UARI0VXMlWXUbb1oksbw.png)*100% Rollout*

Next, test the live environment by clicking the Open Live Environment button.

![Open Live Environment](https://cdn-images-1.medium.com/max/6720/1*gbjgvkK1K3DDWokt7UfIuw.png)*Open Live Environment*

Ypaaaa!!!

![Application Deployed on Live Environment](https://cdn-images-1.medium.com/max/3360/1*tpx0JdK_ruwNLBHJfLpR7w.gif)*Application Deployed on Live Environment*

## Conclusion

Containers have provided us with dramatically more flexibility for running cloud-native applications on physical and virtual infrastructure. But breaking a monolith into a lot of microservices can bring in its own challenges. This is where the Kubernetes Container Orchestration comes in to play. It is important that every modern start-up has a strong repertoire of K8s orchestration from the beginning, otherwise, microservices may make you feel like a shepherd.
> [The complete code of this article resides here…](https://gitlab.com/docker-microservice/ci-cd-example-voting-app-k8s)

![](https://cdn-images-1.medium.com/max/2000/0*Piks8Tu6xUYpF4DU)

**Follow us on [Twitter](https://twitter.com/joinfaun) **🐦** and [Facebook](https://www.facebook.com/faun.dev/) **👥** and [Instagram](https://instagram.com/fauncommunity/) **📷 **and join our [Facebook](https://www.facebook.com/groups/364904580892967/) and [Linkedin](https://www.linkedin.com/company/faundev) Groups **💬**.**

**To join our community Slack team chat **🗣️ **read our weekly Faun topics **🗞️,** and connect with the community **📣** click here⬇**

![](https://cdn-images-1.medium.com/max/3000/1*6P3WpLjGv5v1ucm5dgkucg.png)

### If this post was helpful, please click the clap 👏 button below a few times to show your support for the author! ⬇
