Unknown markup type 10 { type: [33m10[39m, start: [33m54[39m, end: [33m69[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m75[39m, end: [33m78[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m21[39m, end: [33m36[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m78[39m, end: [33m81[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m94[39m, end: [33m102[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m104[39m, end: [33m112[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m114[39m, end: [33m129[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m139[39m, end: [33m146[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m183[39m, end: [33m190[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m245[39m, end: [33m260[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m90[39m, end: [33m95[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m100[39m, end: [33m108[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m176[39m, end: [33m183[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m17[39m, end: [33m25[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m52[39m, end: [33m59[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m139[39m, end: [33m146[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m196[39m, end: [33m212[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m226[39m, end: [33m233[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m366[39m, end: [33m373[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m4[39m, end: [33m13[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m90[39m, end: [33m97[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m164[39m, end: [33m180[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m522[39m, end: [33m531[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m61[39m, end: [33m73[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m75[39m, end: [33m88[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m94[39m, end: [33m103[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m109[39m, end: [33m121[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m126[39m, end: [33m139[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m268[39m, end: [33m277[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m18[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m7[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m5[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m51[39m, end: [33m60[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m14[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m77[39m, end: [33m83[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m5[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m59[39m, end: [33m65[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m39[39m, end: [33m44[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m56[39m, end: [33m62[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m95[39m, end: [33m101[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m108[39m, end: [33m116[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m130[39m, end: [33m135[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m5[39m, end: [33m11[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m72[39m, end: [33m81[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m89[39m, end: [33m96[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m108[39m, end: [33m112[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m135[39m, end: [33m146[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m305[39m, end: [33m316[39m }

# Decorators in Python

A brief description of decorators in Python with an easy example

![Photo by [Shahadat Rahman](https://unsplash.com/@hishahadat?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/python-coding?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)](https://cdn-images-1.medium.com/max/10368/1*D-z53EJJxiBYFmm7qaYD-Q.jpeg)*Photo by [Shahadat Rahman](https://unsplash.com/@hishahadat?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/python-coding?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)*

## Functions

In Python, functions are the first-class objects, which means that:

* Functions are objects â€” they can be referenced to, passed to a variable and returned from other functions as well.

* Functions can be defined inside another function â€” an inner function â€” and can also be passed as an argument to another function.

    def say_name():
        print("Guido van Rossum")
    
    
    def say_nationality():
        print("Netherlands")
    
    
    def say(func):
        return func
    
    
    say(say_name)()
    say(say_nationality)()

Output:

    Guido van Rossum
    Netherlands

Here we are sending two different function references (not parentheses) to say function as an argument that returns the reference again.

This is how** inner function** works:

    def say():
    
        def say_name():
            print("Guido van Rossum")
    
        def say_nationality():
            print("Netherlands")
    
        say_name()
        say_nationality()
    
    say()

Output:

    Guido van Rossum
    Netherlands

## Decorators

Youâ€™ve seen that functions are just like any other object in Python, now let's take an example to see the magic of the Python decorator.

    def say(func):
    
        def employer():
            print("Say something about you.")
    
        def say_name():
            print("My name is Guido van Rossum.")
    
        def say_nationality():
            print("I am from Netherlands.")
    
        def wrapper():
            employer()
            say_name()
            say_nationality()
            func()
    
        return wrapper
    
    @say
    def start_interview():
        print("Real interview Started...")
    
    start_interview()

Output:

    Say something about you.
    My name is Guido van Rossum.
    I am from Netherlands.
    Real interview Started...

Here when we call thestart_interview method. It goes to the decorator functionsay and defines employer, say_name, say_nationality, and the wrapper function and finally it returns the wrapper function reference and calls it where caller function start_interview is called.

## Decorating Functions With Arguments

We can also decorate a function that takes arguments. We can accept these arguments using *args and **kwargs in the wrapper function.

    def say(func):
    
        def wrapper(*args, **kwargs):
            func(*args, **kwargs)
        return wrapper
    
    @say
    def greet(name):
        print("Hello {}".format(name))
    
    greet("Goutom")

Output:

    Hello Goutom

## Returning From Decorated functions

What happens when your decorated function returns something? Just return the caller function from wrapper. Let's look at an example to understand this.

    def my_decorator(func):
    
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    
    @my_decorator
    def doubled(number):
        return number*2
    
    print(doubled(10))

Output:

    20

## Introspection

In Python [Introspection](https://docs.python.org/3/library/inspect.html) is the ability of an object to know about its own attributes at runtime. For instance, a function knows its own name and documentation. Let's print the doubled function name.

    print(doubled.__name__)

Output:

    wrapper

But it should be doubled. After being decorated our doubled function has become confused about its identity because it's being called from wrapper function. To fix this, decorators should use the [@functools.wraps](https://docs.python.org/library/functools.html#functools.wraps) decorator in wrapper function, which will preserve information about the original function. After adding this decorator it will return its original name doubled.

## A Real-World Example

Letâ€™s write a decorator that will calculate function execution time in seconds and prints it in the console.

    import functools
    import time
    
    
    def timer(func):
    
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.perf_counter()
            value = func(*args, **kwargs)
            end_time = time.perf_counter()
            run_time = end_time - start_time
            print("Finished {} in {} secs".format(repr(func.__name__), round(run_time, 3)))
            return value
    
        return wrapper

Now let's use this decorator:

    @timer
    def doubled_and_add(num):
        res = sum([i*2 for i in range(num)])
        print("Result : {}".format(res))
    
    doubled_and_add(100000)
    doubled_and_add(1000000)

Output:

    Result : 9999900000
    Finished â€˜doubled_and_addâ€™ in 0.0119 secs
    Result : 999999000000
    Finished â€˜doubled_and_addâ€™ in 0.0897 secs

## Registering Plugins

Decorators donâ€™t have to wrap the function theyâ€™re decorating. They can also simply register that a function exists and return it unwrapped. This can be used, for instance, to create a lightweight plug-in architecture:

    PLUGINS = dict()
    
    def register(func):
        PLUGINS[func.__name__] = func
        return func
    
    @register
    def add(a, b):
        return a+b
    
    @register
    def multiply(a, b):
        return a*b
    
    def operation(func_name, a, b):
        func = PLUGINS[func_name]
        return func(a, b)
    
    print(PLUGINS)
    print(operation('add', 2, 3))
    print(operation('multiply', 2, 3))

Output :

    {â€˜addâ€™: <function add at 0x7fb27f7a8620>, â€˜multiplyâ€™: <function multiply at 0x7fb27f7a88c8>}
    5
    6

The @register decorator simply stores a reference to the decorated function in the global PLUGINS dict. Note that you do not have to write an inner function or use @functools.wrapsin this example because youâ€™re returning the original function unmodified. The main benefit of this simple plugin architecture is that you do not need to maintain a list of which plugins exist. That list is created when the plugins register themselves. This makes it trivial to add a new plugin: just define the function and decorate it with @register.

## Decorating Classes

There are two different ways to use decorators on classes. The first is by decorating the methods of a class or decorating the whole class.

### A few built-in class decorators

Some commonly used decorators that are built into Python are @classmethod, @staticmethod, and @property. The @classmethod and @staticmethod decorators are used to define methods inside a class namespace thatâ€™s not connected to a particular instance of that class. The @property decorator is used to customize getters and setters for class attributes. Expand the box below for an example using these decorators. You can learn more about built-in decorators [here](https://docs.python.org/3/library/functions.html).

Let's look at an example.

    class Circle:
        def __init__(self, radius):
            self._radius = radius
    
        @property
        def radius(self):
            """Get value of radius"""
            return self._radius
    
        @radius.setter
        def radius(self, value):
            """Set radius, raise error if negative"""
            if value >= 0:
                self._radius = value
            else:
                raise ValueError("Radius must be positive")
    
        @property
        def area(self):
            """Calculate area inside circle"""
            return self.pi() * self.radius**2
    
        def cylinder_volume(self, height):
            """Calculate volume of cylinder with circle as base"""
            return self.area * height
    
        @classmethod
        def unit_circle(cls):
            """Factory method creating a circle with radius 1"""
            return cls(1)
    
        @staticmethod
        def pi():
            """Value of Ï€, could use math.pi instead though"""
            return 3.1415926535

In this class:

* .cylinder_volume() is a regular method.

* .radius is a mutable property: it can be set to a different value. However, by defining a setter method, we can do some error testing to make sure itâ€™s not set to a nonsensical negative number. Properties are accessed as attributes without parentheses.

* .area is an immutable property: properties without .setter() methods canâ€™t be changed. Even though it is defined as a method, it can be retrieved as an attribute without parentheses.

* .unit_circle() is a class method. Itâ€™s not bound to a particular instance of Circle. Class methods are often used as factory methods that can create specific instances of the class.

* .pi() is a static method. Itâ€™s not really dependent on the Circle class, except that itâ€™s part of its namespace. Static methods can be called on either an instance or the class.

Testing in the console:

    >>> c = Circle(5)
    >>> c.radius
    5
    
    >>> c.area
    78.5398163375
    
    >>> c.radius = 2
    >>> c.area
    12.566370614
    
    >>> c.area = 100
    AttributeError: can't set attribute
    
    >>> c.cylinder_volume(height=4)
    50.265482456
    
    >>> c.radius = -1
    ValueError: Radius must be positive
    
    >>> c = Circle.unit_circle()
    >>> c.radius
    1
    
    >>> c.pi()
    3.1415926535
    
    >>> Circle.pi()
    3.1415926535

### Decorate a class method

Here we are using a previously created timer decorator.

    class Calculator:
    
        def __init__(self, num):
            self.num = num
    
        @timer
        def doubled_and_add(self):
            res = sum([i * 2 for i in range(self.num)])
            print("Result : {}".format(res))
    
    c = Calculator(10000)
    c.doubled_and_add()

Output:

    Result : 99990000
    Finished 'doubled_and_add' in 0.001 secs

### Decorate a class

    @timer
    class Calculator:
    
        def __init__(self, num):
            self.num = num
            import time
            time.sleep(2)
    
        def doubled_and_add(self):
            res = sum([i * 2 for i in range(self.num)])
            print("Result : {}".format(res))
    
    c = Calculator(100)

Output:

    Finished 'Calculator' in 2.001 secs

Decorating a class does not decorate its methods. Here, @timer only measures the time it takes to instantiate the class.

## Nesting Decorator

    def hello(func):
        def wrapper():
            print("Hello")
            func()
        return wrapper
    
    def welcome(func):
    
        def wrapper():
            print("Welcome")
            func()
        return wrapper
    
    @hello
    @welcome
    def say():
        print("Greeting Dome")
    
    say()

Output:

    Hello
    Welcome
    Greeting Dome

Think about this as the decorators being executed in the order theyâ€™re listed. In other words, @hello calls @welcome, which calls say().

## Decorators With Arguments

Here repeat handles the arguments of the decorator.

    def repeat(*args_, **kwargs_):
    
        def inner_function(func):
    
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                for _ in range(args_[0]):
                    func(*args, **kwargs)

            return wrapper
    
        return inner_function
    
    
    @repeat(4)
    def say(name):
        print(f"Hello {name}")
    
    say("World")

Output:

    Hello World
    Hello World
    Hello World
    Hello World

## Stateful Decorators

We can use a decorator to keep track of state. As a simple example, we will create a decorator that counts the number of times a function is called.

    def count_calls(func):
    
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            wrapper.num_calls += 1
            print(f"Call {wrapper.num_calls} of {func.__name__!r}")
            return func(*args, **kwargs)
    
        wrapper.num_calls = 0
        return wrapper
    
    
    @count_calls
    def say():
        print("Hello!")
    
    say()
    say()
    say()
    say()
    print(say.num_calls)

Output:

    Call 1 of 'say'
    Hello!
    Call 2 of 'say'
    Hello!
    Call 3 of 'say'
    Hello!
    Call 4 of 'say'
    Hello!
    4

The number of calls to the function is stored in the function attribute num_calls on the wrapper function.

## Classes as Decorators

The best way to maintain state is by using classes. If we want to use class as a decorator it needs to take func as an argument in its .__init__() method. Furthermore, the class needs to be [callable](https://docs.python.org/reference/datamodel.html#emulating-callable-objects) so that it can stand in for the decorated function. For a class to be callable, you implement the special .__call__() method.

    class CountCalls:
        def __init__(self, func):
            functools.update_wrapper(self, func)
            self.func = func
            self.num_calls = 0
    
        def __call__(self, *args, **kwargs):
            self.num_calls += 1
            print(f"Call {self.num_calls} of {self.func.__name__!r}")
            return self.func(*args, **kwargs)
    
    
    @CountCalls
    def say():
        print("Hello!")
    
    say()
    say()
    say()
    say()
    print(say.num_calls)

Output:

    Call 1 of 'say'
    Hello!
    Call 2 of 'say'
    Hello!
    Call 3 of 'say'
    Hello!
    Call 4 of 'say'
    Hello!
    4

## Class-Based Decorators with Arguments

    class ClassDecorator(object):
    
        def __init__(self, arg1, arg2):
            print("Arguements of decorator %s, %s" % (arg1, arg2))
            self.arg1 = arg1
            self.arg2 = arg2
    
        def __call__(self, func):
            functools.update_wrapper(self, func)
    
            def wrapper(*args, **kwargs):
                return func(*args, **kwargs)
            return wrapper
    
    @ClassDecorator("arg1", "arg2")
    def print_args(*args):
        for arg in args:
            print(arg)
    
    print_args(1, 2, 3)

Output:

    Arguements of decorator arg1, arg2
    1
    2
    3
