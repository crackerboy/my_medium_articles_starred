Unknown markup type 10 { type: [33m10[39m, start: [33m99[39m, end: [33m110[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m115[39m, end: [33m122[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m239[39m, end: [33m261[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m22[39m, end: [33m29[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m34[39m, end: [33m45[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m7[39m, end: [33m11[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m325[39m, end: [33m332[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m14[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m13[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m29[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m7[39m, end: [33m25[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m2[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m14[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m96[39m, end: [33m109[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m16[39m, end: [33m31[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m42[39m, end: [33m49[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m102[39m, end: [33m109[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m18[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m34[39m, end: [33m47[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m38[39m, end: [33m45[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m73[39m, end: [33m86[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m312[39m, end: [33m330[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m332[39m, end: [33m357[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m135[39m, end: [33m142[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m164[39m, end: [33m173[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m219[39m, end: [33m222[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m244[39m, end: [33m252[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m385[39m, end: [33m393[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m464[39m, end: [33m467[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m486[39m, end: [33m494[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m514[39m, end: [33m517[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m534[39m, end: [33m542[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m4[39m, end: [33m16[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m90[39m, end: [33m102[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m104[39m, end: [33m118[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m123[39m, end: [33m141[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m107[39m, end: [33m114[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m42[39m, end: [33m50[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m75[39m, end: [33m83[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m36[39m, end: [33m44[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m104[39m, end: [33m111[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m8[39m, end: [33m21[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m21[39m, end: [33m30[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m39[39m, end: [33m51[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m13[39m, end: [33m45[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m119[39m, end: [33m127[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m154[39m, end: [33m162[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m237[39m, end: [33m257[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m279[39m, end: [33m284[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m289[39m, end: [33m298[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m84[39m, end: [33m97[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m145[39m, end: [33m153[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m100[39m, end: [33m105[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m110[39m, end: [33m116[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m27[39m, end: [33m47[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m56[39m, end: [33m61[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m66[39m, end: [33m72[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m76[39m, end: [33m81[39m }

# Post 2 of 3. Our IoT journey through ESP8266, Firebase and Plotly.js

Sunrise at Lac du H√©ron

## TL;DR

This article stands in a series of 3 as detailed below. These 3 articles reflect the Project Architecture we chose to achieve a simple luminosity logging/live plotting project. We hope they will **help developers or students discovering ESP8266 chip and Firebase platform**. Moreover, we believe that the solution developped here can be an interesting alternative to the comprehensive **Google, AWS and Azure IoT solutions** [[link](https://cloud.google.com/solutions/iot/), [link](https://docs.aws.amazon.com/fr_fr/iot/latest/developerguide/what-is-aws-iot.html) and [link](https://docs.microsoft.com/fr-fr/azure/iot-hub/iot-hub-device-management-overview)] when we have to **manage in a simple way only a few connected devices**. (For instance, we won‚Äôt set up a MQTT broker neither deal with a registry.)

![Project Architecture ‚Äî Numbers 1, 2, 3 follow articles numerotation](https://cdn-images-1.medium.com/max/2000/1*J0IGNrEAq3n8zxCZsLO5dQ.png)*Project Architecture ‚Äî Numbers 1, 2, 3 follow articles numerotation*

**Post 1** [[link](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-1-a07db495ac5f)]: We investigate on how an **ESP8266** can regularly make acquisition of an analog data and push its 10-bit equivalent value to a **Firebase Realtime Database**. We finish with considerations on **ESP8266 power saving.**

**Post 2** (this article): We write a **Firebase Cloud Function** in Typescript language to **timestamp **the data just pushed to Firebase Realtime Database.

**Post 3** [[link](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-3-644048e90ca4)]: With a** **web app using **plotly.js library**, we lively plot in a browser the analog data versus time. The web app is hosted with **Firebase Hosting**.

***Post 2. A Firebase Cloud Function appends a timestamp to each value pushed to a Firebase Realtime Database.***

## A) The options we had for timestamping data

### A) 1) In the previous episode‚Ä¶

At the end of Post 1 [[link](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-1-a07db495ac5f)] of this terrific project, we regularly had a new 10-bit value of luminosity that was pushed into a Firebase RealTime Database ‚Äî all done by an ESP8266:

![Firebase Console ‚Äî Each pushed value of luminosity is associated with a unique push ID](https://cdn-images-1.medium.com/max/2000/1*6aFAQyXJo3nQ-0BUjf45Rw.gif)*Firebase Console ‚Äî Each pushed value of luminosity is associated with a unique push ID*

As we want to plot luminosity vs time, **a timestamp associated with each measured value is necessary**. Indeed, we would like something like in the example below:

    {
      "timestamped_measures" : {
        "-LHmx0njIsZ3hkCFzjSC" : {
          "timestamp" : 1532010700350,
          "value" : 910
        },
        "-LHmx1PcieyEm04aOo2a" : {
          "timestamp" : 1532010702641,
          "value" : 907
        },
        "-LHmx1leagyrTQxa9zii" : {
          "timestamp" : 1532010703986,
          "value" : 840
        },
        ...
    }

Each measure should now be an object (described in JSON) having two key/val. pairs, the keys being "timestamp" and "value". And, at an upper level, this object is the value associated with the key called a ‚ÄúFirebase push ID‚Äù, for instance "-LHmx0njIsZ3hkCFzjSC" for the first record in the above example.

The timestamp of a measure should ideally corresponds to the **Unix Epoch time** of the instant the measure was made.

*Note:* The Epoch time is the number of **seconds** that have elapsed since 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970 [[link](https://en.wikipedia.org/wiki/Unix_time)]. Manual conversions from Epoch time to human time (or vice versa) can be made here [[link](https://www.epochconverter.com/)] for instance. As you may have guessed it in the above example, we will use Epoch time expressed in **milliseconds** (not seconds) as the tools we‚Äôll use supply timestamps within this unit.

We investigate now two options to associate a timestamp to a 10-bit value just obtained.

### A) 2) First option: ESP8266 generates a timestamp to associate it with the just obtained value of luminosity

With this option, ESP8266 should be aware of time, *i.e.* have a **Real Time Clock** (hardware or software recreated). It should loop over the following actions:

1. get the 10-bit luminosity measure.

1. get Epoch time.

1. **create an object** with "value" and "timestamp" populated with the measure and the Epoch time. The **ArduinoJson library** we already installed in our previous article [[link](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-1-a07db495ac5f)] can deal with that [[link](https://github.com/bblanchon/ArduinoJson#serialization)].

1. **push this object **to our Firebase Realtime Database. This is possible with the **FirebaseArduino library** [[link](https://github.com/firebase/firebase-arduino), [link](https://firebase-arduino.readthedocs.io/en/latest/#_CPPv2N15FirebaseArduino4pushERK6StringRK11JsonVariant)] we already know from our previous article [[link](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-1-a07db495ac5f)]. The function for that purpose has this prototype:

    String push(*const* String &*path*, *const* JsonVariant &*value*)

Steps 1, 3 and 4 should be okay but step 2 is the tricky point. Indeed, when we read this **NodeMCU Documentation** at **RTC Time Module** page [[link](https://nodemcu.readthedocs.io/en/master/en/modules/rtctime/)], we realize that RTC in ESP8266:

* is a software module,

* has an accuracy depending on chip temperature,

* needs to synchronize via SNTP or NTP (thus consuming power),

* will lose time in case of an unexpected reset.

Okay! Too much drawbacks! Let‚Äôs forget this option and let‚Äôs dive into a more realistic one‚Ä¶

*Note:* Using NTP with ESP8266 is however described here for example: [[link](https://tttapa.github.io/ESP8266/Chap15%20-%20NTP.html)].

### A) 3) Second option: A Firebase Cloud Function issues the timestamp when a value is pushed to the Firebase Realtime Database.

Firstly, what are Firebase Cloud Functions?

![Cloud Functions for Firebase logo](https://cdn-images-1.medium.com/max/2000/1*GnWThKAgUSof2W4jUBiuyw.png)*Cloud Functions for Firebase logo*

**Firebase Cloud Functions** (or ‚ÄúCloud Functions for Firebase‚Äù, [[link](https://firebase.google.com/docs/functions/)]) are part of **Google Cloud Platform** and are **functions executed in a Node environment **on Google servers. A Firebase Cloud Function can be:

* called from an app involving Firebase (directly or via a HTTP request),

* automatically triggered upon an event on Firebase products:

![Means to invoke a Firebase Cloud Function. The one we‚Äôll use is underlined.](https://cdn-images-1.medium.com/max/2000/1*KFCG8rn6hoiFbCit5vihqA.jpeg)*Means to invoke a Firebase Cloud Function. The one we‚Äôll use is underlined.*

You might have already guessed it, what we need is a **Realtime Database trigger**. Each time a measure is pushed to Firebase Realtime Database by ESP8266, a Firebase Cloud Function will be triggered in order to timestamp the measure. With that solution,** we maintain the work done by ESP8266 to the minimum (and thus its power consumption).**

The **small drawback** of this option is that we will timestamp the push to Firebase Realtime Database, not the measure. But the temporal gap between them is only about seconds, depending on network latency. In our previous article [[link](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-1-a07db495ac5f)], we used to make a measure every 5 minutes ; a delay of 1 or 2 seconds on the timestamp is therefore not an issue here.

*Note: *Firebase Cloud Functions are part of what is sometimes called **Functions as a Service** (FaaS) and are one aspect of the famous **serverless architecture**, *i.e.* we don‚Äôt need to provide our own servers to host and run them.

## B) Writing our Cloud Function

As written in [https://firebase.google.com/docs/functions/](https://firebase.google.com/docs/functions/) we should:

![Firebase Cloud Functions workflow](https://cdn-images-1.medium.com/max/2000/1*EpQ-zjvWf49XmMFfe3_EnQ.jpeg)*Firebase Cloud Functions workflow*

So let‚Äôs follow these steps! But before let‚Äôs give **a few documentation links**:
[**Get started: write and deploy your first functions | Firebase**
*To get started with Cloud Functions, try working through this tutorial, which starts with the required setup tasks and‚Ä¶*firebase.google.com](https://firebase.google.com/docs/functions/get-started)

This page ‚Üë and its links often include videos from [Doug Stevenson](undefined). We can find them on YouTube under the following list. It is worth watching all them, Cloud Functions are nicely explained and fundamental concepts like **Promises** too!

<center><iframe width="560" height="315" src="https://www.youtube.com/embed/videoseries" frameborder="0" allowfullscreen></iframe></center>

And finally, if you want to become a master in Firebase Cloud Functions üòÉ, head to this impressive Github repo of Cloud Functions samples (mostly in JavaScript):
[**firebase/functions-samples**
*Collection of sample apps showcasing popular use cases using Cloud Functions for Firebase - firebase/functions-samples*github.com](https://github.com/firebase/functions-samples)

### B) 1) Setting up the tools managing Firebase Cloud Functions

To sum up :

*Note:* Each time there is an action to perform, it is preceeded by a lowercase letter like **a. b. c. **etc.

**a. **If not installed yet on our computer, we install **Node.js** [[link](https://nodejs.org/en/)]. It will also install Node Package Manager (**NPM**). Once done, we check version in command line. At the time of writing, it should be ‚â•8 for Node.js and ‚â•6 for NPM. To do so, open a terminal. Personnaly, as we develop on a Windows 10 computer, the terminal is cmd.exe. Do it right now with **admin rights** as some of the future commands will require it. Then, to check installed versions, run from any folder:

node --version

npm --version

**b. **We install **Firebase Command Line Interface** (CLI, a necessary set of Firebase command line tools) by running, from any folder:

npm install -g firebase-tools

Again, firebase --version will give the installed version. At the time of writing, it should be ‚â•4.

-g installs Firebase tools ‚Äúglobally‚Äù *i.e.* we will be able to use the Firebase tools from any **project directory**. A project directory is a directory on our computer that hosts during its edition the Cloud Function(s) related to the Firebase project we‚Äôre working on.

**c. **We authenticate with Firebase services by running (a few permissions will be asked):

firebase login

*Note:* Here, we have to authenticate with the same account than the one we used while setting up esp8266-rocks Firebase project in our previous article [[link](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-1-a07db495ac5f)].

*Note:* Use first firebase logout if you were logged-in with another account.

It should result in this:

![Successful Firebase CLI Login](https://cdn-images-1.medium.com/max/2000/1*tXmTWUE8RzzbSqkCj3BTPw.jpeg)*Successful Firebase CLI Login*

**d.** In our computer development directory (**c:\_APP** for us), we create **a project directory** that we call esp8266:

**c:\_APP>**md esp8266 on Windows (or mkdir esp8266 on Linux).

We navigate to it and run the command to set up the ‚Äúfunctions‚Äù purpose of the project (same commands for Windows/Linux):

    **c:\_APP>**cd esp8266
    **c:\_APP\esp8266>**firebase init functions

This is what we get:

![‚Äúfirebase init functions‚Äù command](https://cdn-images-1.medium.com/max/2000/1*CAo0B7eo3VV_4a8HXmKLDg.jpeg)*‚Äúfirebase init functions‚Äù command*

**e.** A few questions are asked after we respond **Yes **to proceed:

* Of course, we choose to **associate **the esp8266 project directory with the esp8266-rocksFirebase project:

![Project Setup](https://cdn-images-1.medium.com/max/2000/1*CPR-pZ7LjcI8kB43uWLGkA.jpeg)*Project Setup*

* We then choose **TypeScript language**. Usually programs for Node environment are written in JavaScript but TypeScript has a lot of advantages over JavaScript, the first one being likely **(optional) static typing**. In fact, it handles the pillars of Object Oriented Programming. However we have to confess that our function will be so simple today that using TypeScript will provide no real benefit... But the scaffolding for writing later more sophisticated functions in Typescript will have been set up. A short and nice introduction to TypeScript is here: [[link](http://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)].

![Functions Setup (1)](https://cdn-images-1.medium.com/max/2000/1*0jc5JzG35ol_V2fmYTXpDQ.jpeg)*Functions Setup (1)*

*Note:* Check later this blog post [[link](https://firebase.googleblog.com/2018/01/why-you-should-use-typescript-for.html)] from [Doug Stevenson](undefined) for TypeScript pros while writing Cloud Functions. Read also [[link](https://github.com/firebase/functions-samples/tree/Node-8/typescript-getting-started)] for additional workflow details while using TypeScript with Cloud Functions. You will also learn the key differences between a file in TypeScript and its equivalent in JavaScript ES6 (import <-> require, export const <-> exports.)

* We answer **Yes** to the next question concerning the use of **TSLint**. It is a powerful debug tool but unfortunately we won‚Äôt have time to tackle with it in this article! At least it will have been set up.

* At last, we accept to install dependencies with NPM: (be prepared to have a bunch of files installed!)

![Function Setup (2)](https://cdn-images-1.medium.com/max/2000/1*ihNvCFijVN1VGwJ_XsQhxw.jpeg)*Function Setup (2)*

**f.** Now we‚Äôre done! On the graph below we have an (incomplete) tree of the project directory. What‚Äôs important to us is that inside the esp8266 project directory, a functions directory was created. In this one we find a src directory that hosts index.ts , the file where we will write our Cloud Function in TypeScript. At the time of deploying the Cloud Function on Google servers, the index.ts file will be **transpiled **to JavaScript, by a **transpiler **program called tsc, resulting in the index.js file stored in the lib directory. It‚Äôs index.js that will be run by Node.js on Google servers.

The node_modules directory hosts the dependencies (as Node packages/modules) indicated in package.json: firebase-admin and firebase-functions. But it also stores the dependencies of these dependencies‚Ä¶ That‚Äôs why it is so huge.

    esp8266/
     |
     +- .firebaserc
     |
     +- firebase.json
     |
     +- functions/
         |
         +- package.json
         |
         +- src/
         |   |
         |   +- index.ts   # where we will write our Cloud Function
         |
         +- lib/ 
         |   |
         |   +- index.js   # result of index.ts transpilation
         |
         +- node_modules/  # directory where dependencies (declared in
                           # package.json) are installed

### B) 2) Writing the Cloud Function

We launch an editor on our project directory. For instance, **Visual Studio Code** [[link](https://code.visualstudio.com/)] is launched over the esp8266 folder that way:

    **c:\_app\esp8266>**code .

This is what we get:

![After we launched VS Code](https://cdn-images-1.medium.com/max/2344/1*u2rkenS4sJptMzNr8dkfhQ.jpeg)*After we launched VS Code*

There is already some (commented) code in index.ts. This is in fact the code of a **function called on a HTTP request**, not what we need today (but it‚Äôs worth testing it along with the first YouTube video embedded above in this post). Remember, we are about to write a **Realtime Database trigger function**.

*Note:* If we needed to write several Cloud Functions, they would all fit in index.ts, one after one.

We copy/paste the following code in index.ts. It is fully commented to understand how it proceeds. Of course, we save this file!

<iframe src="https://medium.com/media/dff56beda91d55f4c1c484e5e3cd2f3d" frameborder=0></iframe>

### B) 3) Deploy, test and monitor the Cloud Function

**Cloud Function deployment**

In terminal, we run:

    **c:\_APP\esp8266>**firebase deploy --only functions

Unfortunately, there is a **known issue while predeploying (*i.e. *tslint & tsc execution) with Windows 10 **(cmd.exe):

![Known issue with Windows 10 while deploying Cloud Functions](https://cdn-images-1.medium.com/max/2000/1*hVp0GNrdNndSQXU3nd0oXQ.jpeg)*Known issue with Windows 10 while deploying Cloud Functions*

This issue is discussed here : [[link](https://github.com/firebase/firebase-tools/issues/610), [link](https://stackoverflow.com/questions/47756264/cloud-functions-firebase-cli-predeploy-error-typescript)]. We used this sustainable workaround:

* Replace firebase.json current content:

    {
      "functions": {
        "predeploy": [
          "npm --prefix \"$RESOURCE_DIR\" run lint",
          "npm --prefix \"$RESOURCE_DIR\" run build"
        ]
      }
    }

by:

    {
      "functions": {
      "predeploy": "npm --prefix functions run lint && npm --prefix functions run build"
      }
    }

* Then, replace in the "scripts" part of package.json the lines:

    "lint": "tslint --project tsconfig.json",
    "build": "tsc",

by:

    "lint": "./node_modules/.bin/tslint -p tslint.json",
    "build": "./node_modules/.bin/tsc",

We try again firebase deploy --only functions and this time it‚Äôs ok! By curiosity, you can have a look at the obtained index.js file.

![Successful Cloud Function deploy](https://cdn-images-1.medium.com/max/2000/1*UCQ_aJeeusncG84UqdUvSg.jpeg)*Successful Cloud Function deploy*

*Note:* It takes about 30 seconds for Cloud Functions to be deployed on Google servers. As we will repeat many times the write-deploy-test process, deploying Cloud Functions locally during development could be an interesting option. We can find more information on **Cloud Functions emulator **here: [[link](https://firebase.google.com/docs/functions/local-emulator)].

**Cloud Function test**

In the animation below, we trigger the Cloud Function. To achieve this, we simulate in Firebase Console a new measure pushed to Firebase Realtime Databasemeasures node. Instantly, the Cloud Function detects this creation and push to the timestamped_measures node the object with value and timestamp keys we talked about before. It also assign it a unique push ID. The value of the timestamp is the Epoch time in ms provided by Google servers, it should be accurate.

![Firebase Console ‚Äî Cloud Function at work!](https://cdn-images-1.medium.com/max/2000/1*MSioPaOnDex_OP_0qWbS0w.gif)*Firebase Console ‚Äî Cloud Function at work!*

**Cloud Function monitoring**

While debugging, it is useful to monitor the execution of the Cloud Function and to console.log() a few informations as we did at the end of our index.ts file:

    console.log(`Detected new measure ${original} with pushId ${pushId}`);

Where can we see those logs? In Firebase Console ([https://console.firebase.google.com](https://console.firebase.google.com)):

![Firebase Console ‚Äî Monitoring the Cloud Function](https://cdn-images-1.medium.com/max/2528/1*yJolVpBoF_1_m0w8V2KYyg.jpeg)*Firebase Console ‚Äî Monitoring the Cloud Function*

**How to undeploy a Cloud Function?**

Curiously, it‚Äôs not possible to delete a Cloud Function from Firebase Console. We have to go to **Google Cloud Platform Console** ([https://console.cloud.google.com](https://console.cloud.google.com)), then to choose ‚ÄúCloud Functions‚Äù and then to select the Cloud Function we want to delete:

![GCP Console ‚Äî Undeploying a Cloud Function](https://cdn-images-1.medium.com/max/2606/1*iuLPD1i0l5twYrOH3CgNpg.jpeg)*GCP Console ‚Äî Undeploying a Cloud Function*

**How many times can we invoke our Cloud Functions per month?**

With **Firebase ‚ÄúSpark pricing plan‚Äù** (the free one), we can make up to 125K invocations per month in the limits of 5K invocation per day and 50 invocation per 100 seconds [[link](https://stackoverflow.com/questions/42905204/function-killed-error-quota-exceeded)]. **This thresholds can be quickly reached! **To know the current number of invocations (it‚Äôs easy to estimate it), we hit **Project Overview** in Firebase Console:

![Firebase Console ‚Äî Project Overview](https://cdn-images-1.medium.com/max/2000/1*iJHD5-c9eccbYKSC_B-tXQ.png)*Firebase Console ‚Äî Project Overview*

*Note: *When the invocation quota is exceeded, the function execution is paused and timestamps will be the ones when the function execution resumes! We should detect the ‚Äúquota exceeded‚Äù event and /or consider the **‚ÄúBlaze pricing plan‚Äù**.

**Hmmh‚Ä¶ wait! Do we have to change database access rules ?**

First, remember that the Cloud Function we wrote has admin rights and can thus do anything with the database regardless of the rules we‚Äôll set up.

But it‚Äôs good practice to set access rules for each node we have in the database, knowing also that .read and .write rules cascade to deeper paths (see [[link](https://firebase.google.com/docs/database/security/)]).

So, for our new node named timestamped_measures, we set .read and .write to false as, for the moment, no third party needs to access this node. But this will change in the next episode [[link](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-3-644048e90ca4)].

    {
      "rules": {
        "measures": {
          ".read": "false",
          ".write": "false" 
        },
        "timestamped_measures": {
          ".read": "false",
          ".write": "false" 
        }
      }
    }

## Conclusion

In this article, we wrote our first **Firebase Cloud Function** to timestamp measures made by ESP8266. No doubt you will adopt them in your own projects as it is an easy way to run code that cannot be run by client side.

As live data is now presented in a good shape, we will plot it dynamically with a **web app **using **plotly.js **in the third and last article of this serie. Hopefully we‚Äôll post it before Christmas 2018 üéÑ üéÅ! So stay tuned!

**Links to the posts: [**Post 1](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-1-a07db495ac5f), Post 2, [Post 3](https://medium.com/@o.lourme/our-iot-journey-through-esp8266-firebase-angular-and-plotly-js-part-3-644048e90ca4), [GitHub](https://github.com/olivierlourme/esp8266webapp) and [Live Demo](https://esp8266-rocks.firebaseapp.com/).

**Check also this post:** [GCP-Cloud IoT Core with ESP32 and Mongoose OS](https://medium.com/@o.lourme/gcp-cloudiotcore-esp32-mongooseos-1st-5c88d8134ac7?source=---------4------------------).
