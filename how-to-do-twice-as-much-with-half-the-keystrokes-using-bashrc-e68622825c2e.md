Unknown markup type 10 { type: [33m10[39m, start: [33m95[39m, end: [33m102[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m18[39m, end: [33m25[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m99[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m4[39m, end: [33m9[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m133[39m, end: [33m135[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m159[39m, end: [33m161[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m322[39m, end: [33m324[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m328[39m, end: [33m330[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m431[39m, end: [33m432[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m437[39m, end: [33m438[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m20[39m, end: [33m27[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m161[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m171[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m63[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m100[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m83[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m148[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m100[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m49[39m, end: [33m51[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m61[39m, end: [33m63[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m241[39m, end: [33m243[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m389[39m, end: [33m396[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m288[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m4[39m, end: [33m6[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m169[39m, end: [33m183[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m209[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m107[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m5[39m, end: [33m18[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m40[39m, end: [33m46[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m91[39m, end: [33m99[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m312[39m, end: [33m319[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m171[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m121[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m142[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m88[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m26[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m181[39m, end: [33m191[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m2[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m13[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m24[39m, end: [33m33[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m2[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m41[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m18[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m38[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m21[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m14[39m }
Unknown markup type 10 { type: [33m10[39m, start: [33m0[39m, end: [33m1[39m }

# How To Do Twice as Much With Half the Keystrokes Using .bashrc

An overview of time-saving aliases and functions that make it easy to create a useful Bash prompt

![Photo by [Goran Ivos](https://unsplash.com/@goran_ivos?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)](https://cdn-images-1.medium.com/max/6848/0*uaM8mkJR7ky8A9jB)*Photo by [Goran Ivos](https://unsplash.com/@goran_ivos?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)*

In my [recent post about setting up Ubuntu with Bash scripts](https://medium.com/better-programming/how-to-set-up-a-fresh-ubuntu-desktop-using-only-dotfiles-and-bash-scripts-159fd8a038b8), I briefly alluded to the magic of .bashrc. This didn’t really do it justice, so here’s a quick post that offers a bit more detail about what the Bash configuration file can do.

My current configuration hugely improves my workflow and saves me well over 50% of the keystrokes I would have to employ without it. Let’s look at some examples of aliases, functions, and prompt configurations that can improve our workflow by helping us be more efficient with fewer key presses.

![](https://cdn-images-1.medium.com/max/2000/0*1wcRA2iHfVido1mL.png)

## Bash Aliases

A smartly written .bashrc can save a whole lot of keystrokes. We can take advantage of this in the literal sense by using [bash aliases](https://www.gnu.org/software/bash/manual/html_node/Aliases.html), or strings that expand to larger commands. For an indicative example, here is a Bash alias for copying files in the terminal:

    # Always copy contents of directories (r)ecursively and explain (v) what was done
    alias cp='cp -rv'

The alias command defines the string we’ll type, followed by what that string will expand to. We can override existing commands like cp above. On its own, the cp command will only copy files, not directories, and succeeds silently. With this alias, we need not remember to pass those two flags, nor do we need to remember cd or ls as the location of our copied file to confirm that it’s there. Now, just those two key presses (for c and d) will do all of that for us.

Here are a few more .bashrc aliases for passing flags with common functions.

    # List contents with colors for file types, (A)lmost all hidden files (without . and ..), in (C)olumns, with class indicators (F)
    alias ls='ls --color=auto -ACF'

    # List contents with colors for file types, (a)ll hidden entries (including . and ..), use (l)ong listing format, with class indicators (F)
    alias ll='ls --color=auto -alF'

    # Explain (v) what was done when moving a file
    alias mv='mv -v'

    # Create any non-existent (p)arent directories and explain (v) what was done
    alias mkdir='mkdir -pv'

    # Always try to (c)ontinue getting a partially-downloaded file
    alias wget='wget -c'

Aliases come in handy when we want to avoid typing long commands, too. Here are a few I use when working with Python environments:

    alias pym='python3 manage.py'
    alias mkenv='python3 -m venv env'
    alias startenv='source env/bin/activate && which python3'
    alias stopenv='deactivate'

## Bash Functions

One downside of the aliases above is they’re rather static — they’ll always expand to exactly the text declared. For a Bash alias that takes arguments, we’ll need to create a function. We can do this like so:

    # Show contents of the directory after changing to it
    function cd () {
      builtin cd "$1"
      ls -ACF
    }

I can’t begin to tally how many times I’ve typed cd and then ls immediately after to see the contents of the directory I’m now in. With this function set up, it all happens with just those two letters. The function takes the first argument, $1, as the location to change directory to, then prints the contents of that directory into nicely formatted columns with file-type indicators. The builtin part is necessary to get Bash to allow us to override this default command.

Bash functions are very useful when it comes to downloading or upgrading software, too. I previously spent at least a few minutes every couple weeks downloading the new extended version of the [static-site generator Hugo](https://gohugo.io/categories/releases), thanks to their excellent shipping frequency. With a function, I only need to pass in the version, and the upgrade happens in a few seconds.

    # Hugo install or upgrade
    function gethugo () {
      wget -q -P tmp/ https://github.com/gohugoio/hugo/releases/download/v"$@"/hugo_extended_"$@"_Linux-64bit.tar.gz
      tar xf tmp/hugo_extended_"$@"_Linux-64bit.tar.gz -C tmp/
      sudo mv -f tmp/hugo /usr/local/bin/
      rm -rf tmp/
      hugo version
    }

The $@ notation simply takes all the arguments given, replacing its spot in the function. To run the above function and download Hugo version 0.57.2, we use the command gethugo 0.57.2.

I’ve got one for [Golang](https://golang.org/), too:

    function getgolang () {
      sudo rm -rf /usr/local/go
      wget -q -P tmp/ https://dl.google.com/go/go"$@".linux-amd64.tar.gz
      sudo tar -C /usr/local -xzf tmp/go"$@".linux-amd64.tar.gz
      rm -rf tmp/
      go version
    }

Or how about a function that adds a remote origin URL for GitLab to the current repository?

    function glab () {
      git remote set-url origin --add git@gitlab.com:"$@"/"${PWD##*/}".git
      git remote -v
    }

With glab username, we can create a new origin URL for the current Git repository with our username on GitLab.com. Pushing to a new remote URL [automatically creates a new private GitLab repository](https://victoria.dev/verbose/how-to-write-bash-one-liners-for-cloning-and-managing-github-and-gitlab-repositories/#a-bash-one-liner-to-create-and-push-many-repositories-on-gitlab), so this is a useful shortcut for creating backups!

Bash functions are really only limited by the possibilities of scripting, of which there are, practically, few limits. If there’s anything we do on a frequent basis that requires typing a few lines into a terminal, we can probably create a Bash function for it!

## Bash Prompt

Besides directory contents, it’s also useful to see the full path of the directory we’re in. The Bash prompt can show us this path, along with other useful information like our current Git branch. To make it more readable, we can define colors for each part of the prompt. Here’s how we can set up our prompt in .bashrc to accomplish this:

    # Colour codes are cumbersome, so let's name them
    txtcyn='\[\e[0;96m\]' # Cyan
    txtpur='\[\e[0;35m\]' # Purple
    txtwht='\[\e[0;37m\]' # White
    txtrst='\[\e[0m\]' # Text Reset

    # Which (C)olour for what part of the prompt?
    pathC="${txtcyn}"
    gitC="${txtpur}"
    pointerC="${txtwht}"
    normalC="${txtrst}"

    # Get the name of our branch and put parenthesis around it
    gitBranch() {
      git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
    }

    # Build the prompt
    export PS1="${pathC}\w ${gitC}\$(gitBranch) ${pointerC}\$${normalC} "

Result:

    ~/github/myrepo (master) $

Naming the colors helps to easily identify where one color starts and stops and where the next one begins. The prompt that we see in our terminal is defined by the string following export PS1, with each component of the prompt set with an [escape sequence](https://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/bash-prompt-escape-sequences.html). Let’s break that down:

* \w displays the current working directory

* \$(gitBranch) calls the gitBranch function defined above, which displays the current Git branch,

* \$ will display a “$” if you are a normal user or in normal user mode and a “#” if you are at the root

The [full list of Bash escape sequences](https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html) can help us display many more bits of information, including even the time and date. Bash prompts are highly customizable and individual, so feel free to set it up any way you please.

Here are a few options that put information front and center and can help us to work more efficiently.

### For the procrastination-averse

Username and current time with seconds, in 24-hour HH:MM:SS format:

    export PS1="${userC}\u ${normalC}at \t >"

    user at 09:35:55 >

### For those who always like to know where they stand

Full file path on a separate line and username:

    export PS1="${pathC}\w${normalC}\n\u:"

    ~/github/myrepo
    user:

### For the minimalist

    export PS1=">"

    >

We can build many practical prompts with just the basic escape sequences; once we start to integrate functions with prompts, as in the Git branch example, things can get really complicated. Whether this amount of complication is an addition or a detriment to your productivity, only you can know for sure.

Many fancy Bash prompts are possible with programs readily available with a quick search. I’ve intentionally not provided samples here because, well, if you can tend to get as excited about this stuff as I can, it might be a couple of hours before you get back to what you were doing before you started reading this post, and I just can’t have that on my conscience.

We’ve hopefully struck a nice balance now between time invested and usefulness gained from our Bash configuration file. I hope you use your newly recovered keystroke capacity for good.
